name: CI/CD Pipeline

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  packages: write
  issues: write

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
      - run: npm install
      - name: Lint commit messages
        run: npx commitlint --from $(git rev-list --max-parents=0 HEAD) --to HEAD || echo "Commit linting warnings found but continuing build"

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
      - run: npm install
      - name: Run tests
        run: npm test
        env:
          # Use mock mode for tests to avoid hitting real API endpoints
          NODE_ENV: test
          MOCK_API: true

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
      - run: npm install
      - name: Build
        run: npm run build
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build
          path: build/
          retention-days: 1
  
  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [build]
    # Allow releases when pushing to main or when merging a PR from dev to main
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')
    outputs:
      version: ${{ steps.package-version.outputs.VERSION }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # This ensures all tags are fetched for proper versioning
          fetch-tags: true
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Install dependencies
        run: npm install
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build
          path: build/
      
      # Conditionally setup npm token for main branch only
      - name: Setup npm token for main branch
        if: github.ref == 'refs/heads/main'
        run: |
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc
          echo "registry=https://registry.npmjs.org/" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc
          npm whoami || echo "npm token verification failed"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          
      # Generate semantic version, changelog from commit messages, and publish to NPM if on main branch
      - name: Run Semantic Release - Main Branch
        id: semantic-release
        if: github.ref == 'refs/heads/main'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          # Enable debug mode for more verbose output
          DEBUG: "semantic-release:*"
        run: npx semantic-release --debug
        continue-on-error: false
      
      - name: Run Semantic Release - Dev Branch
        id: semantic-release-dev
        if: github.ref == 'refs/heads/dev'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # No NPM_TOKEN needed as we've excluded npm plugin from verifyConditions
          # Enable debug mode for more verbose output
          DEBUG: "semantic-release:*"
        run: npx semantic-release --debug -e ./.release-dev.json
        continue-on-error: false
      
      # Store the new version number as an output variable
      - name: Get version from package.json
        id: package-version
        if: (github.ref == 'refs/heads/main' && steps.semantic-release.outcome == 'success') || (github.ref == 'refs/heads/dev' && steps.semantic-release-dev.outcome == 'success')
        run: echo "VERSION=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      # Config.yaml version update is handled by semantic-release/exec plugin
      
      # For dev branch, log the version but don't update config.yaml or publish to NPM
      - name: Log dev version
        if: github.ref == 'refs/heads/dev' && steps.semantic-release-dev.outcome == 'success'
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "Created pre-release version $VERSION on dev branch (not updating config.yaml or publishing to npm)"
          
      # Verify NPM publishing for main branch
      - name: Verify NPM publish
        if: github.ref == 'refs/heads/main' && steps.semantic-release.outcome == 'success'
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "Release version $VERSION was published to npm"
          # Check if package was published successfully
          npm view mcp-grocy-api version | grep $VERSION && echo "âœ… Successfully published to npm" || echo "âš ï¸ Publication to npm could not be verified"

  validate-release:
    name: Validate Release
    needs: [release]
    if: github.ref == 'refs/heads/main' && needs.release.outputs.version != ''
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install and test released package
        run: |
          mkdir -p test-install
          cd test-install
          npm init -y
          # Update package.json to support ESM
          sed -i 's/"main": "index.js"/"main": "index.js",\\n  "type": "module"/g' package.json
          npm install -g mcp-grocy-api@${{ needs.release.outputs.version }}
          
          # Create a basic test script to validate the package
          cat > test-import.js << 'EOF'
          console.log("Testing mcp-grocy-api package import...");
          try {
            const mcpGrocyApi = require('mcp-grocy-api');
            console.log("âœ… Successfully imported mcp-grocy-api");
            console.log(`ðŸ“¦ Package version: ${mcpGrocyApi.version || 'unknown'}`);
            console.log("ðŸ§ª Testing package structure...");
            
            // Log available exports to verify package structure
            console.log("Available exports:", Object.keys(mcpGrocyApi));
            
            if (typeof mcpGrocyApi === 'object') {
              console.log("âœ… Package exports an object as expected");
            } else {
              console.error("âŒ Package does not export an object");
              process.exit(1);
            }
            
            console.log("ðŸŽ‰ All basic validation checks passed!");
          } catch (error) {
            console.error("âŒ Error importing or using the package:", error.message);
            process.exit(1);
          }
          EOF
          
          # Create a simpler MCP server test that won't have process management issues in CI
          cat > test-mcp-server.js << 'EOF'
          import { exec } from 'child_process';
          import { promisify } from 'util';
          import http from 'http';
          
          const execAsync = promisify(exec);
          
          // Send a JSON-RPC 2.0 request to the server
          function sendJsonRpcRequest(request) {
            return new Promise((resolve, reject) => {
              const data = JSON.stringify(request);
              
              // Use curl instead of direct HTTP for better reliability in CI
              execAsync(`curl -s -X POST -H "Content-Type: application/json" -d '${data}' http://localhost:8123/`)
                .then(({ stdout }) => {
                  try {
                    resolve(JSON.parse(stdout));
                  } catch (error) {
                    reject(new Error(`Invalid JSON response: ${error.message}`));
                  }
                })
                .catch(reject);
            });
          }
          
          // Test the MCP server
          async function testMcpServer() {
            try {
              // Start the MCP server in the background
              console.log("Starting mcp-grocy-api server in mock mode...");
              exec('mcp-grocy-api --mock --port=8123 &');
              
              // Wait for server to start
              await new Promise(resolve => setTimeout(resolve, 3000));
              
              // Test tools/list endpoint
              console.log("Testing tools/list endpoint...");
              const toolsListRequest = {
                jsonrpc: "2.0",
                id: "test-1",
                method: "tools/list"
              };
              
              const toolsListResponse = await sendJsonRpcRequest(toolsListRequest);
              
              // Validate response
              if (toolsListResponse.jsonrpc !== "2.0") {
                throw new Error("Invalid jsonrpc version in response");
              }
              
              if (toolsListResponse.id !== "test-1") {
                throw new Error("Invalid id in response");
              }
              
              if (!toolsListResponse.result || !toolsListResponse.result.tools || !Array.isArray(toolsListResponse.result.tools)) {
                throw new Error("Invalid tools list in response");
              }
              
              console.log(`âœ… tools/list returned ${toolsListResponse.result.tools.length} tools`);
              
              console.log("ðŸŽ‰ All MCP server tests passed!");
              return true;
            } catch (error) {
              console.error("âŒ MCP server test failed:", error.message);
              return false;
            } finally {
              // Cleanup: kill any running server
              exec('pkill -f "mcp-grocy-api --mock" || true');
            }
          }
          
          testMcpServer().then(success => {
            process.exit(success ? 0 : 1);
          });
          EOF
          
          # Run the basic test script first
          echo "Running package validation test..."
          node test-import.js
          
          # Run the MCP server test in mock mode
          echo "Running MCP server test..."
          node test-mcp-server.js || echo "MCP server test failed, but continuing validation process"
      
      # Run comprehensive MCP compatibility tests
      - name: Run MCP compatibility tests
        run: |
          cd test-install
          
          # Copy the check-tools script from the repo
          cp ../scripts/check-tools.js ./
          
          # Create mcp-test.js for additional API validation
          cat > mcp-test.js << 'EOF'
          console.log("Testing mcp-grocy-api MCP compatibility...");
          
          try {
            const packageName = 'mcp-grocy-api';
            
            // Try to import the module
            import(packageName).then(module => {
              console.log(`âœ… Successfully imported ${packageName}`);
              
              // Check if the package exports conform to MCP
              if (typeof module.default !== 'function' && typeof module.default !== 'object') {
                throw new Error('Package does not export a valid MCP server function or object');
              }
              
              // Check if the package has a tools list
              if (typeof module.default === 'object' && (!module.default.tools || typeof module.default.tools !== 'object')) {
                throw new Error('Package does not export tools list in the MCP format');
              }
              
              console.log('âœ… Package exports conform to MCP specifications');
              console.log('ðŸŽ‰ All MCP compatibility tests passed!');
              process.exit(0);
            }).catch(err => {
              console.error(`âŒ Error importing or validating ${packageName}:`, err.message);
              process.exit(1);
            });
          } catch (error) {
            console.error('âŒ Error in MCP compatibility test:', error.message);
            process.exit(1);
          }
          EOF
          
          # Run the validation scripts to verify MCP compatibility
          echo "Running JSON-RPC 2.0 MCP validation..."
          node check-tools.js --validate-release
          
          echo "Running MCP API structure validation..."
          node mcp-test.js

  update-submodule:
    name: Update hassio-addons Submodule
    runs-on: ubuntu-latest
    needs: [validate-release]
    # Only update the submodule when changes are in main branch and release was successful
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.release.outputs.version != ''
    steps:
      - name: Checkout hassio-addons repository
        uses: actions/checkout@v4
        with:
          repository: saya6k/hassio-addons
          token: ${{ secrets.HASSIO_ADDONS_TOKEN }}
          path: hassio-addons
      
      - name: Setup Git configuration
        working-directory: hassio-addons
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
      
      - name: Check if submodule exists
        id: check-submodule
        working-directory: hassio-addons
        run: |
          if grep -q "mcp-grocy-api" .gitmodules 2>/dev/null; then
            echo "SUBMODULE_EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "SUBMODULE_EXISTS=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Update existing submodule
        if: steps.check-submodule.outputs.SUBMODULE_EXISTS == 'true'
        working-directory: hassio-addons
        run: |
          # More robust submodule update that doesn't fail if there are issues with other submodules
          git config -f .gitmodules --get-regexp '^submodule\.mcp-grocy-api\.path$' || true
          
          # Check if the directory exists and is a git repository
          if [ -d "mcp-grocy-api" ] && [ -d "mcp-grocy-api/.git" ]; then
            cd mcp-grocy-api
            git fetch
            git checkout main
            git pull
            cd ..
          else
            # If directory doesn't exist or isn't a git repo, initialize just this submodule
            git submodule init mcp-grocy-api
            git submodule update --remote mcp-grocy-api
          fi
          
          # Commit the updated submodule
          git add mcp-grocy-api
          git commit -m "chore: update mcp-grocy-api submodule to latest version" || echo "No changes to commit"
          git push || echo "No changes to push"
      
      - name: Check and update gitignore
        if: steps.check-submodule.outputs.SUBMODULE_EXISTS == 'false'
        working-directory: hassio-addons
        run: |
          # Check if mcp-grocy-api is in .gitignore
          if grep -q "mcp-grocy-api" .gitignore 2>/dev/null; then
            # Remove or comment out the line from .gitignore
            sed -i 's/mcp-grocy-api/#mcp-grocy-api - submodule now/g' .gitignore
            git add .gitignore
            git commit -m "chore: update .gitignore to allow mcp-grocy-api submodule"
            git push
          fi
      
      - name: Add new submodule
        if: steps.check-submodule.outputs.SUBMODULE_EXISTS == 'false'
        working-directory: hassio-addons
        run: |
          # Add the new submodule with force flag
          git submodule add -f https://github.com/saya6k/mcp-grocy-api.git mcp-grocy-api
          
          # Directly initialize just this submodule without trying to init others
          cd mcp-grocy-api
          git checkout main
          cd ..
          
          # Commit the new submodule
          git add .gitmodules mcp-grocy-api
          git commit -m "chore: add mcp-grocy-api submodule"
          git push
